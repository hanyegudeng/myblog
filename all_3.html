<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  寒夜孤灯
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="寒夜孤灯" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.hanyegudeng.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 寒夜孤灯</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">首页</a></li>
    <li><a href="archives.html">目录</a></li>
    <li><a href="about.html">关于</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="iOS.html">iOS</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="PHP.html">PHP</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E6%9D%82%E8%B0%88.html">杂谈</a></li>
        
            <li><a href="%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87.html">疑难杂症</a></li>
        
            <li><a href="Redis.html">Redis</a></li>
        
            <li><a href="React%20Native.html">React Native</a></li>
        
            <li><a href="%E8%BF%90%E7%BB%B4.html">运维</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14864371153216.html">
                
                  <h1>Objective-C中的锁及应用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>转自：http://foredoomed.org/blog/2014/02/26/olocks-in-objective-c/</code></p>

<p>在多线程编程中，锁是非常重要的工具，而Objective-C提供了好几种不同类型的锁，下面就来看一下这些锁都是怎么用的。</p>

<ol>
<li>POSIX Mutex Lock</li>
</ol>

<p>Mutex lock也就是互斥锁，是Unix/Linux平台上提供的一套同步机制。互斥锁提供了三个函数，从函数名就可以知道他们的作用：</p>

<pre><code>int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
</code></pre>

<p>函数pthread_mutex_trylock和pthread_mutex_lock的功能完全一致，只不过前者在获取锁失败的情况下会立即返回，而后者则会一直阻塞在那里直到获取到锁为止。互斥锁的使用非常的简单，直接调用上面三个API就可以了：</p>

<pre><code>pthread_mutex_t mutex;
void MyInitFunction()
{
    pthread_mutex_init(&amp;mutex, NULL);
}
 
void MyLockingFunction()
{
    pthread_mutex_lock(&amp;mutex);
    // Do work.
    pthread_mutex_unlock(&amp;mutex);
}
</code></pre>

<ol>
<li>NSLock</li>
</ol>

<p>NSLock类使用的是POSIX线程来实现它的锁操作，而且需要注意的是必须在同一线程内发送unlock消息，否则会发生不确定的情况。NSLock不能被用来实现迭代锁，因为如果发生lock消息两次的话，整个线程将被永久锁住。</p>

<pre><code>BOOL moreToDo = YES;
NSLock *theLock = [[NSLock alloc] init];
...
while (moreToDo) {
    /* Do another increment of calculation */
    /* until there’s no more to do. */
    if ([theLock tryLock]) {
        /* Update display used by all threads. */
        [theLock unlock];
    }
}
</code></pre>

<ol>
<li>@synchronized</li>
</ol>

<p>@synchronized是在Objective-C中最简单方法，只要有个Objective-C对象就可以完成线程同步操作。</p>

<pre><code>- (void)myMethod:(id)anObj
{
    @synchronized(anObj)
    {
        // Everything between the braces is protected by the @synchronized directive.
    }
}
</code></pre>

<p>需要注意的是，@synchronized会隐式地添加异常处理代码，也就是当发生异常时会自动释放互斥锁，所以会有一定的性能损耗。</p>

<ol>
<li>NSRecursiveLock</li>
</ol>

<p>NSRecursiveLock类定义了可以被同一线程获取多次而不会造成死锁的锁。NSRecursiveLock可以被用在递归调用中，但是只有当多次获取的锁全部释放时，NSRecursiveLock才能被其他线程获取。</p>

<pre><code>NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];
 
void MyRecursiveFunction(int value)
{
    [theLock lock];
    if (value != 0)
    {
        --value;
        MyRecursiveFunction(value);
    }
    [theLock unlock];
}
 
MyRecursiveFunction(5);
</code></pre>

<ol>
<li>NSConditionLock</li>
</ol>

<p>NSConditionLock定义了一个条件互斥锁，也就是当条件成立时就会获取到锁，反之就会释放锁。因为这个特性，条件锁可以被用在有特定顺序的处理流程中，比如生产者-消费者问题。</p>

<pre><code>id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];
 
// producer
while(true)
{
    [condLock lock];
    /* Add data to the queue. */
    [condLock unlockWithCondition:HAS_DATA];
}
 
// consumer
while (true)
{
    [condLock lockWhenCondition:HAS_DATA];
    /* Remove data from the queue. */
    [condLock unlockWithCondition:(isEmpty ? NO_DATA : HAS_DATA)];
 
    // Process the data locally.
}
</code></pre>

<p>条件锁的初始状态是NO_DATA，所以生产者线程在这个时候就会获取到锁，生产完成后再把状态设置为HAS_DATA；这时消费者线程发现条件变成HAS_DATA后就可以获取到锁，直到消费结束后再把状态设置成NO_DATA。</p>

<ol>
<li>NSDistributedLock</li>
</ol>

<p>NSDistributedLock是跨进程的分布式锁，底层是用文件系统实现的互斥锁。NSDistributedLock没有实现NSLocking协议，所以没有会阻塞线程的lock方法，取而代之的是非阻塞的tryLock方法。NSDistributedLock只有在锁持有者显式地释放后才会被释放，也就是说当持有锁的应用崩溃后，其他应用就不能访问受保护的共享资源了。</p>

<ol>
<li>NSCondition</li>
</ol>

<p>NSCondition类是互斥锁和条件锁的结合体，也就是一个线程在等待信号而阻塞时，可以被另外一个线程唤醒。需要注意的是，由于操作系统实现的差异，即使在代码中没有发送signal消息，线程也有可能被唤醒，所以需要增加谓词变量来保证程序的正确性。</p>

<pre><code>[cocoaCondition lock];
while (timeToDoWork &lt;= 0)
    [cocoaCondition wait];
 
timeToDoWork--;
 
// Do real work here.
 
[cocoaCondition unlock];
</code></pre>

<p>在其他线程中唤醒：</p>

<pre><code>[cocoaCondition lock];
timeToDoWork++;
[cocoaCondition signal];
[cocoaCondition unlock];
</code></pre>

<ol>
<li>POSIX Conditions</li>
</ol>

<p>在Unix/Linux平台上也提供了一套条件互斥锁的API：</p>

<pre><code>// 初始化
int pthread_cond_init (pthread_cond_t *cond, pthread_condattr_t *attr);
 
// 等待（会阻塞）
int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mut);
 
// 定时等待
int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mut, const struct timespec *abstime);
 
// 唤醒
int pthread_cond_signal (pthread_cond_t *cond);
 
// 广播唤醒
int pthread_cond_broadcast (pthread_cond_t *cond);
 
// 销毁
int pthread_cond_destroy (pthread_cond_t *cond);
</code></pre>

<p>和NSCondition类一样，POSIX Conditions也需要和谓词配合使用以确保程序的正确性。</p>

<pre><code>pthread_mutex_t mutex;
pthread_cond_t condition;
Boolean     ready_to_go = true;
 
void MyCondInitFunction()
{
    pthread_mutex_init(&amp;mutex);
    pthread_cond_init(&amp;condition, NULL);
}
 
void MyWaitOnConditionFunction()
{
    // Lock the mutex.
    pthread_mutex_lock(&amp;mutex);
 
    // If the predicate is already set, then the while loop is bypassed;
    // otherwise, the thread sleeps until the predicate is set.
    while(ready_to_go == false)
    {
        pthread_cond_wait(&amp;condition, &amp;mutex);
    }
 
    // Do work. (The mutex should stay locked.)
 
    // Reset the predicate and release the mutex.
    ready_to_go = false;
    pthread_mutex_unlock(&amp;mutex);
}
 
void SignalThreadUsingCondition()
{
    // At this point, there should be work for the other thread to do.
    pthread_mutex_lock(&amp;mutex);
    ready_to_go = true;
 
    // Signal the other thread to begin work.
    pthread_cond_signal(&amp;condition);
 
    pthread_mutex_unlock(&amp;mutex);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/7</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14864326299242.html">
                
                  <h1>iOS RSA的网络安全模型、iOS签名机制总结（登录、token安全、签名）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>转自：http://www.jianshu.com/p/2927ca2b3719</code></p>

<p>摘要</p>

<p>最近公司准备做一个安全级别比较高的项目：技术总监给我们提出了一个这样子的需求:在http请求过程中，即使嗅探器捕获到网络请求的链接也无法去请求到数据。经过一番思考，觉得支付宝的签名完全符合这样子的需求。但是之前自己对签名、RSA等知识也是知道的很少，所以花了一番功夫学习了一下。本文将针对RSA登录和http请求作讲解，希望对大家有所帮助。</p>

<p>一.登录、登录保持（http请求）</p>

<p>登录机制</p>

<p>登录机制大概可以分为一下三个阶段：</p>

<pre><code>1. 登录验证：是指客户端提供用户名和密码，向服务器提出登录请求，服务器判断客户端是否可以登录并向客户端确认。
2. 登录保持：是指客户端登录后， 服务器能够分辨出已登录的客户端，并为其持续提供登录权限的服务器。
3. 登出：是指客户端主动退出登录状态。
</code></pre>

<p>第一种网络请求情况（安全级别：II）</p>

<p>一般的情况是这个样子的：一但用户登陆成功（单方面MD5加密：服务器加密则客户端不加密，客户端加密则明文传输），服务器为客户端分配sessionID(也可以称为userID),当然有些服务器不但为客户端分配了userID还有可能会为用户提供token了(这个下面会做解释)，然后每次网络请求都将sessionID当做参数传递给服务器。</p>

<p>优点</p>

<p>能够保持用户登录状态、区分用户，相对于不返回任何信息的登录要安全了一些。</p>

<p>缺点</p>

<p>如果通过网络嗅探器（例如：青花瓷）可以获取到http链接，这样子服务器返回的sessionID便会被获取到，这样子依然会造成信息泄露，并且还能被伪造请求（浏览器请求）。</p>

<p>第二种网络请求情况 （安全级别：III）</p>

<p>第一种存在明显的安全隐患，但是目前市面上的好多app依然采用第一种方法去实现登录、网络请求，但是对于安全级别较高的app，已经不再适用了。所以在此基础上进行优化----采用非对称加密（公钥、私钥）。</p>

<p>登录模型</p>

<p>客户端第一次发出登录请求时， 用户密码以明文的方式传输， 一旦被截获， 后果严重。因此密码需要加密，例如可采用RSA非对称加密。具体流程如下：</p>

<p>客户端向服务器第一次发起登录请求（不传输用户名和密码）。<br/>
服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。<br/>
客户端收到公钥后， 加密用户密码， 向服务器发起第二次登录请求（传输用户名和加密后的密码）。<br/>
服务器利用保留的私钥对密文进行解密，得到真正的密码。<br/>
第三种网络请求情况（安全级别：IIII）</p>

<p>再仔细核对上述登录流程， 我们发现服务器判断用户是否登录， 完全依赖于sessionId, 一旦其被截获， 黑客就能够模拟出用户的请求。于是我们需要引入token的概念： 用户登录成功后， 服务器不但为其分配了sessionId, 还分配了token， token是维持登录状态的关键秘密数据。在服务器向客户端发送的token数据，也需要加密。于是一次登录的细节再次扩展。</p>

<p>客户端向服务器第一次发起登录请求（不传输用户名和密码）。<br/>
服务器利用RSA算法产生一对公钥和私钥。并保留私钥， 将公钥发送给客户端。<br/>
客户端收到公钥后， 加密用户密码，向服务器发送用户名和加密后的用户密码； 同时另外产生一对公钥和私钥，自己保留私钥, 向服务器发送公钥； 于是第二次登录请求传输了用户名和加密后的密码以及客户端生成的公钥。<br/>
服务器利用保留的私钥对密文进行解密，得到真正的密码。 经过判断， 确定用户可以登录后，生成sessionId和token， 同时利用客户端发送的公钥，对token进行加密。最后将sessionId和加密后的token返还给客户端。<br/>
客户端利用自己生成的私钥对token密文解密， 得到真正的token。<br/>
图示如下：<br/>
<img src="media/14864326299242/1678515-b2469d974979f153.png" alt="1678515-b2469d974979f153"/><br/>
登录保持（也就是http数据请求阶段）</p>

<p>引入token后，http请求被获取问题便可得到解决。 服务器将token和其它的一些变量， 利用散列加密算法得到签名后，连同sessionId一并发送给服务器； 服务器取出保存于服务器端的token,利用相同的法则生成校验签名， 如果客户端签名与服务器的校验签名一致， 就认为请求来自登录的客户端。（支付宝一样的机制）<br/>
结构图如下：<br/>
<img src="media/14864326299242/1678515-9297d2d63a3e12a1.png" alt="1678515-9297d2d63a3e12a1"/><br/>
注：token失效的两种情况：</p>

<pre><code> 1. 用户登录出系统
 2. token在后台的规定时间内失效（每个token都是有时间效应的）
</code></pre>

<p>失效原理：<br/>
在服务器端的redis中删除相应key为session的键值对。</p>

<p>二.散列算法</p>

<p>散列是信息的提炼，通常其长度要比信息小得多，且为一个固定长度。加密性强的散列一定是不可逆的，这就意味着通过散列结果，无法推出任何部分的原始信息。任何输入信息的变化，哪怕仅一位，都将导致散列结果的明显变化，这称之为雪崩效应。散列还应该是防冲突的，即找不出具有相同散列结果的两条信息。具有这些特性的散列结果就可以用于验证信息是否被修改。</p>

<p>散列算法可以用来加密token生成签名， 以便token信息不暴露在网络同时还能验证登录的有效性。</p>

<p>MD5</p>

<p>全写： Message Digest Algorithm MD5（中文名为消息摘要算法第五版）<br/>
输出： 128bit</p>

<p>MD5算法具有以下特点：</p>

<p>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br/>
2、容易计算：从原数据计算出MD5值很容易。<br/>
3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br/>
4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。<br/>
5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。<br/>
缺陷：Md5一度被认为十分靠谱。2004年8月17日的美国加州圣巴巴拉的国际密码学会议（Crypto’2004）上，来自中国山东大学的王小云教授做了破译MD5、HAVAL-128、 MD4和RIPEMD算法的报告，公布了MD系列算法的破解结果。2009年，冯登国、谢涛二人利用差分攻击，将MD5的碰撞算法复杂度从王小云的2<sup>42进一步降低到2<sup>21，极端情况下甚至可以降低至2<sup>10。仅仅2<sup>21的复杂度意味着即便是在2008年的计算机上，也只要几秒便可以找到一对碰撞。Md5已老，</sup></sup></sup></sup> 在安全性要求较高的场合，不建议使用。</p>

<p>SHA1</p>

<p>全名： 安全哈希算法（Secure Hash Algorithm）输出： 160bit<br/>
与Md5比较<br/>
相同点：因为二者均由MD4导出，SHA-1和MD5彼此很相似。相应的，他们的强度和其他特性也是相似。不同点：1. 对强行攻击的安全性：最显著和最重要的区别是SHA-1摘要比MD5摘要长32 位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对MD5是2<sup>128数量级的操作，而对SHA-1则是2<sup>160数量级的操作。这样，SHA-1对强行攻击有更大的强度。2.</sup></sup> 对密码分析的安全性：由于MD5的设计，易受密码分析的攻击，SHA-1显得不易受这样的攻击。3. 速度：在相同的硬件上，SHA-1的运行速度比MD5慢。</p>

<p>加盐</p>

<p>所谓加盐， 就是在原本需要加密的信息基础上，糅入其它内容salt。签名的生成就是一次加盐。</p>

<p>对称加密</p>

<p>本系统使用对称加密对用户密码进行加密以及生成token字符串。<br/>
AuthCode加密<br/>
AuthCode是康盛科技发明的加密方式， 开源产品Discuz的密码是用这个算法进行加密。但是有点遗憾，这个函数所有权属于康盛创想，并不能自由使用的。不知使用是否有风险？？<br/>
AES加密<br/>
高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p>

<p>非对称加密</p>

<p>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。<br/>
算法描述：<br/>
（1）选择一对不同的、足够大的素数p，q。<br/>
（2）计算n=pq。<br/>
（3）计算f(n)=(p-1)(q-1)，同时对p, q严加保密，不让任何人知道。<br/>
（4）找一个与f(n)互质的数e（公钥指数），且1&lt;e&lt;f(n)。<br/>
（5）计算d（私钥指数），使得de≡1 mod f(n)。这个公式也可以表达为d ≡e-1 mod f(n)注，≡是数论中表示同余的符号。<br/>
（6）公钥KU=(e,n)，私钥KR=(d,n)。<br/>
（7）加密时，先将明文变换成0至n-1的一个整数M。若明文较长，可先分割成适当的组，然后再进行交换。设密文为C，则加密过程为：<br/>
<img src="media/14864326299242/14864329106667.jpg" alt=""/></p>

<p>（8）解密过程为：<br/>
<img src="media/14864326299242/14864328974432.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/2/7</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14829148983172.html">
                
                  <h1>开始学习ES6</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><a href="https://zhuanlan.zhihu.com/p/22712172">https://zhuanlan.zhihu.com/p/22712172</a><br/>
安装配置需要的环境<br/>
1.安装Node JS。这个简单<br/>
检查是否安装成功<code>npm -v；node -v</code><br/>
2.修改npm源为淘宝<code>npm config set registry https://registry.npm.taobao.org/</code><br/>
3.安装Gulp<code>npm install -g gulp</code><br/>
<code>有的时候需要sudo哦</code><br/>
查看是否安装成功<code>gulp -v</code><br/>
4.安装gulp-babel和gulp-watch<code>npm install gulp-babel；npm install gulp-babel</code><br/>
5.配置Gulp<br/>
对于我这从来没搞过js的小白，查看上面文章的时候比较懵逼啊。创建到哪里，怎么跑不懂啊<br/>
下面是我尝试的结果<br/>
a.创建一个测试目录<br/>
b.进入该目录，创建3个文件<br/>
    <img src="media/14829148983172/14829151957077.jpg" alt=""/><br/>
c.运行<code>npm install</code><br/>
d.运行<code>npm gulp</code><br/>
贴上上面几个文件的代码：<br/>
ES6Test.html</p>

<pre><code class="language-&lt;html&gt;">&lt;head&gt;
    &lt;script src=&quot;./ES6Test.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;title&gt;ES6测试&lt;/title&gt;
&lt;body&gt;
&lt;h1&gt;ES6测试&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>ES6Test.js文件</p>

<pre><code class="language-let">    name:&#39;Hi 你好，我是小明&#39;,
    getName(){
        return &#39;Hello &#39; + this.name;
    }
}

alert(hello.getName());
</code></pre>

<p>gulpfile.js</p>

<pre><code class="language-var">var babel = require(&#39;gulp-babel&#39;);
var watch = require(&#39;gulp-watch&#39;);

gulp.task(&#39;default&#39;,function(){
    return watch(&#39;js/*.js&#39;)
        .pipe(babel())
        .pipe(gulp.dest(&#39;dest/js&#39;)
        );
});
</code></pre>

<p>我用的是IDE是webstorm，然后在html上直接点击chrome浏览器，就可以查看效果</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/12/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='React%20Native.html'>React Native</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14828902722239.html">
                
                  <h1>Git统计每个人提交的Commit次数和代码行数</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>提交次数<code>git shortlog --numbered --summary</code><br/>
查看所有的commit数<code>git log --oneline | wc -l</code><br/>
提交删除行数<code>git log --author=&quot;$(git config --get user.name)&quot; --pretty=tformat: --numstat | awk &#39;{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf &quot;added lines: %s removed lines : %s total lines: %s\n&quot;,add,subs,loc }&#39;</code><br/>
使用cloc统计代码行数给力：<br/>
安装<code>brew install cloc</code><br/>
统计目录下的所有文件，代码行数<code>cloc ./</code><br/>
排除文件夹<code>cloc ./ --exclude-dir=Pods,Tests,Utility</code></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/12/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Mac.html'>Mac</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14823842291606.html">
                
                  <h1>创建一个RN项目</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在机器上如何安装React Native以及需要的工具等，网上都有。<br/>
1.创建项目<code>react-native init MyRNDemo</code><br/>
2.npm install<br/>
3.npm start</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/12/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='React%20Native.html'>React Native</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_2.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_4.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>寒夜孤灯</h1>
                <div class="site-des">寒夜里的一盏孤灯</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>分类</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="iOS.html"><strong>iOS</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="PHP.html"><strong>PHP</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E6%9D%82%E8%B0%88.html"><strong>杂谈</strong></a>
        
            <a href="%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87.html"><strong>疑难杂症</strong></a>
        
            <a href="Redis.html"><strong>Redis</strong></a>
        
            <a href="React%20Native.html"><strong>React Native</strong></a>
        
            <a href="%E8%BF%90%E7%BB%B4.html"><strong>运维</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>最新文章</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15036253170711.html">Xcode Build Settings 分析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15030458956017.html">发现女儿早恋，这个爸爸的做法刷爆朋友圈！</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15017301944011.html">iOS应用内跳转到系统设置页面</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15017289646320.html">iOS APP提交审核被拒因Guideline 2.5.2 - Performance - Software Requirements</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14966306832048.html">Swift使用pod找不到文件的解决方案</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2017
通过 <a target="_blank" href="http://www.mweb.im">MWeb</a>制作&nbsp; <a target="_blank" href="http://www.miitbeian.gov.cn/">沪ICP备15015428号-1</a>&nbsp; 
</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
