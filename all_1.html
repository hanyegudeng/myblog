<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  寒夜孤灯
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="寒夜孤灯" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.hanyegudeng.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; 寒夜孤灯</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">首页</a></li>
    <li><a href="archives.html">目录</a></li>
    <li><a href="about.html">关于</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="iOS.html">iOS</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="PHP.html">PHP</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E6%9D%82%E8%B0%88.html">杂谈</a></li>
        
            <li><a href="%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87.html">疑难杂症</a></li>
        
            <li><a href="Redis.html">Redis</a></li>
        
            <li><a href="React%20Native.html">React Native</a></li>
        
            <li><a href="%E8%BF%90%E7%BB%B4.html">运维</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14942311266949.html">
                
                  <h1>iOS监听键盘的删除按键事件</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>原文地址：<a href="http://blog.csdn.net/que_li/article/details/50586702">http://blog.csdn.net/que_li/article/details/50586702</a></strong></p>

<p>需求场景描述 <br/>
最近项目里有个场景，搜索添加成员的时候，需要类似于微信创建讨论组加人时的效果：启动搜索输入文本，点击删除文本，当文本全删除完的时候，在点击删除按键，可以删除选中的人，或者取消搜索状态。</p>

<p>技术要点 <br/>
这里，最主要的难点就是监听键盘删除键的点击事件。不管你用的是UITextView还是UITextField，当它们本身没有内容的时候点击删除按键，其实delegate是没有任何响应的，这里就需要我们用其它的办法监听到点击事件。</p>

<p>实现过程 <br/>
查看API我们不难发现，其实系统是有事件抛出来的：</p>

<pre><code> @protocol UIKeyInput &lt;UITextInputTraits&gt;

    - (BOOL)hasText;
    - (void)insertText:(NSString *)text;
    - (void)deleteBackward;

    @end
</code></pre>

<p>所以，我们现在要做的就是实现这个协议，拿到deleteBackward的回调。 <br/>
不过这个协议已经被UITextField实现了：</p>

<pre><code>    NS_CLASS_AVAILABLE_IOS(2_0) @interface UITextField : UIControl &lt;UITextInput, NSCoding&gt; 

</code></pre>

<p>但是UITextFieldDelegate并没有抛出来。 <br/>
所以，我们要做的就是从UITextField里面抛出这个协议。 <br/>
自定义一个类，继承UITextField  </p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

@protocol keyInputTextFieldDelegate &lt;NSObject&gt;

- (void) deleteBackward;

@end

@interface UITextFieldKeybordDelete : UITextField
@property (nonatomic,weak) id&lt;keyInputTextFieldDelegate&gt;keyInputDelegate;
@end
</code></pre>

<pre><code>#import &quot;UITextFieldKeybordDelete.h&quot;

@implementation UITextFieldKeybordDelete

/*
// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
- (void)drawRect:(CGRect)rect {
    // Drawing code
}
*/

- (void) deleteBackward{
    [super deleteBackward];
    
    if (_keyInputDelegate &amp;&amp; [_keyInputDelegate respondsToSelector:@selector(deleteBackward)]) {
        [_keyInputDelegate deleteBackward];
    }
    
}

@end
</code></pre>

<p>到此，我们已经能知道键盘的删除事件了，后面需要做什么逻辑，直接在deleteBackward回调里做就OK！</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/8</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14939612071684.html">
                
                  <h1>Swift - Realm数据库的使用详解（附样例）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>原文：<a href="http://www.hangge.com/blog/cache/detail_891.html">http://www.hangge.com/blog/cache/detail_891.html</a></p>

<p>1，什么是Realm<br/>
Realm 于2014 年7月发布，是一个跨平台的移动数据库引擎，专门为移动应用的数据持久化而生。其目的是要取代 Core Data 和 SQLite。</p>

<p>2，关于Realm，你要知道下面几点：<br/>
（1）使用简单，大部分常用的功能（比如插入、查询等）都可以用一行简单的代码轻松完成，学习成本低。<br/>
（2）Realm 不是基于 Core Data，也不是基于 SQLite 封装构建的。它有自己的数据库存储引擎。<br/>
（3）Realm 具有良好的跨平台特性，可以在 iOS 和 Android 平台上共同使用。代码可以使用 Swift 、 Objective-C 以及 Java 语言来编写。<br/>
（4）Realm 还提供了一个轻量级的数据库查看工具（Realm Browser）。你也可以用它进行一些简单的编辑操作（比如插入和删除操作） </p>

<p>3，支持的类型<br/>
（1）Realm 支持以下的属性类型：Bool、Int8、Int16、Int32、Int64、Double、Float、String、Date（精度到秒）以及Data.<br/>
（2）也可以使用 List<object> 和 Object 来建立诸如一对多、一对一之类的关系模型，此外 Object 的子类也支持此功能。</p>

<p>4，Realm的安装配置 <br/>
（1）先去 Realm 的官网去下载最新框架：<a href="http://static.realm.io/downloads/swift/latest">http://static.realm.io/downloads/swift/latest</a><br/>
（2）拖拽 RealmSwift.framework 和 Realm.framework 文件到”Embedded Binaries”选项中。选中 Copy items if needed 并点击 Finish<br/>
原文:Swift - Realm数据库的使用详解（附样例）</p>

<p>5，将数据插入到数据库中<br/>
下面代码判断默认数据库中是否有数据，如果没有的话将几个自定义对像插入到数据库中。<br/>
（1）这里以个人消费记录为例，我们先定义消费类别类，和具体消费记录类</p>

<pre><code>import Foundation
import RealmSwift
 
//消费类型
class ConsumeType:Object {
    //类型名
    dynamic var name = &quot;&quot;
}
 
//消费条目
class ConsumeItem:Object {
    //条目名
    dynamic var name = &quot;&quot;
    //金额
    dynamic var cost = 0.00
    //时间
    dynamic var date = Date()
    //所属消费类别
    dynamic var type:ConsumeType?
}
</code></pre>

<p>（2）判断数据库记录是否为空，空的话则插入数据库（这里以默认数据库为例）<br/>
```<br/>
import UIKit<br/>
import RealmSwift</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    //使用默认的数据库
    let realm = try! Realm()
    //查询所有的消费记录
    let items = realm.objects(ConsumeItem.self)
    //已经有记录的话就不插入了
    if items.count&gt;0 {
        return
    }

    //创建两个消费类型
    let type1 = ConsumeType()
    type1.name = &quot;购物&quot;
    let type2 = ConsumeType()
    type2.name = &quot;娱乐&quot;

    //创建三个消费记录
    let item1 = ConsumeItem(value: [&quot;买一台电脑&quot;,5999.00,Date(),type1]) //可使用数组创建

    let item2 = ConsumeItem()
    item2.name = &quot;看一场电影&quot;
    item2.cost = 30.00
    item2.date = Date(timeIntervalSinceNow: -36000)
    item2.type = type2

    let item3 = ConsumeItem()
    item3.name = &quot;买一包泡面&quot;
    item3.cost = 2.50
    item3.date = Date(timeIntervalSinceNow: -72000)
    item3.type = type1

    // 数据持久化操作（类型记录也会自动添加的）
    try! realm.write {
        realm.add(item1)
        realm.add(item2)
        realm.add(item3)
    }

    //打印出数据库地址
    print(realm.configuration.fileURL)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
</code></pre>

<p>}<br/>
```<br/>
6，Data类型数据的存取<br/>
参考另一篇文章：Swift - Realm数据库中图片的插入、读取（Data类型数据的存储） </p>

<p>7，使用Realm Browser查看数据库<br/><br/>
（1）默认数据库是应用的 Documents 文件夹下的一个名为“default.realm”。</p>

<p>//打印出数据库地址<br/>
print(realm.configuration.fileURL)<br/>
（2）使用 Realm Browser 工具可以很方便的对.realm数据库进行读取和编辑（在 App Store 中搜索 Realm Browser 即可下载）。<br/>
可以看到，上面的几个对象已经成功的插入到数据库中来。</p>

<p>8，从数据库中读取记录并显示到表格中来<br/>
（1）通过查询操作，Realm 将会返回包含 Object 集合的 Results 实例。Results 的表现和 Array 十分相似，并且包含在 Results 中的对象能够通过索引下标进行访问。 <br/>
（2）所有的查询（包括查询和属性访问）在 Realm 中都是延迟加载的，只有当属性被访问时，才能够读取相应的数据。 <br/>
（3）查询结果并不是数据的拷贝：修改查询结果（在写入事务中）会直接修改硬盘上的数据。</p>

<p>下面我们把库里的数据加载出来，并通过表格显示出来。<br/>
效果图如下：<br/>
原文:Swift - Realm数据库的使用详解（附样例）</p>

<p>代码如下：<br/>
```<br/>
import UIKit<br/>
import RealmSwift</p>

<p>class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource  {</p>

<pre><code>@IBOutlet weak var tableView: UITableView!

var dformatter = DateFormatter()

//保存从数据库中查询出来的结果集
var consumeItems:Results&lt;ConsumeItem&gt;?

override func viewDidLoad() {
    super.viewDidLoad()

    self.dformatter.dateFormat = &quot;MM月dd日 HH:mm&quot;

    self.tableView!.delegate = self
    self.tableView!.dataSource = self
    //创建一个重用的单元格
    self.tableView!.register(UITableViewCell.self, forCellReuseIdentifier: &quot;MyCell&quot;)

    //使用默认的数据库
    let realm = try! Realm()
    //查询所有的消费记录
    consumeItems = realm.objects(ConsumeItem.self)
}

//在本例中，只有一个分区
func numberOfSections(in tableView: UITableView) -&gt; Int {
    return 1;
}

//返回表格行数（也就是返回控件数）
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    return self.consumeItems!.count
}

//创建各单元显示内容(创建参数indexPath指定的单元）
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath)
    -&gt; UITableViewCell {
    //同一形式的单元格重复使用，在声明时已注册
    let cell = UITableViewCell(style: .value1, reuseIdentifier: &quot;MyCell&quot;)
    let item = self.consumeItems![indexPath.row]
    cell.textLabel?.text = item.name + &quot; ￥&quot; + String(format: &quot;%.1f&quot;, item.cost)
    cell.detailTextLabel?.text = self.dformatter.string(from: item.date)
    return cell
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
</code></pre>

<p>}<br/>
<code><br/>
9，查询前N条数据<br/>
Realm无法直接限制查询数量。所以我们如果想要查出部分数据（比如前5条记录），也是全部查出来后在结果集中捞取。<br/>
</code><br/>
//查询并取出前5条数据<br/>
let dogs = try! Realm().objects(Dog.self)<br/>
for i in 0..&lt;5 {<br/>
    let dog = dogs[i]<br/>
    // ...<br/>
}<br/>
```<br/>
Realm为何无法限制查询数量？<br/>
通常查询数据库数据时，我们可以在sql语句中添加一些限制语句（比如rownum，limit，top等）来限制返回的结果集的行数。<br/>
但我们使用Realm会发现，它没有这种分页功能，感觉不管查什么都是把所有的结果都捞出来。比如我们只要User表的前10条数据，那么做法是先查询出所有的User数据，再从结果集中取出前10条数据。<br/>
有人可能会担心，如果数据库中数据非常多，那每次都这么查不会影响性能吗？<br/>
其实大可放心，由于Realm都是延迟加载的，只有当属性被访问时，才能够读取相应的数据。不像通常数据库，查询后，查询结果是从数据库拷贝一份出来放在内存中的。而Realm的查询结果应该说是数据库数据的引用，就算你查出来，如果不用也不会占用什么内存。</p>

<p>10，支持断言查询(Predicate)，这样可以通过条件查询特定数据<br/>
同时可以使用链式查询数据。<br/>
```<br/>
//查询花费超过10元的消费记录(使用断言字符串查询)<br/>
consumeItems = realm.objects(ConsumeItem.self).filter(&quot;cost &gt; 10&quot;)</p>

<p>//查询花费超过10元的购物记录(使用 NSPredicate 查询)<br/>
let predicate = NSPredicate(format: &quot;type.name = &#39;购物&#39; AND cost &gt; 10&quot;)<br/>
consumeItems = realm.objects(ConsumeItem.self).filter(predicate)</p>

<p>//使用链式查询<br/>
consumeItems = realm.objects(ConsumeItem.self).filter(&quot;cost &gt; 10&quot;).filter(&quot;type.name = &#39;购物&#39;&quot;)</p>

<pre><code>
</code></pre>

<p>支持的断言：<br/>
比较操作数(comparison operand)可以是属性名称或者某个常量，但至少有一个操作数必须是属性名称；<br/>
比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!=, 以及 BETWEEN 支持 int、long、long long、float、double 以及 NSDate 属性类型的比较，比如说 age == 45；<br/>
相等比较 ==以及!=，比如说Results<Employee>().filter(&quot;company == %@&quot;, company)<br/>
比较操作符 == and != 支持布尔属性；<br/>
对于 NSString 和 NSData 属性来说，我们支持 ==、!=、BEGINSWITH、CONTAINS 以及 ENDSWITH 操作符，比如说 name CONTAINS ‘Ja’；<br/>
字符串支持忽略大小写的比较方式，比如说 name CONTAINS[c] ‘Ja’ ，注意到其中字符的大小写将被忽略；<br/>
Realm 支持以下复合操作符：“AND”、“OR” 以及 “NOT”。比如说 name BEGINSWITH ‘J’ AND age &gt;= 32；<br/>
包含操作符 IN，比如说 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；<br/>
==、!=支持与 nil 比较，比如说 Results<Company>().filter(&quot;ceo == nil&quot;)。注意到这只适用于有关系的对象，这里 ceo 是 Company 模型的一个属性。<br/>
ANY 比较，比如说 ANY student.age &lt; 21<br/>
注意，虽然我们不支持复合表达式类型(aggregate expression type)，但是我们支持对对象的值使用 BETWEEN 操作符类型。比如说，Results<Person>.filter(&quot;age BETWEEN %@&quot;, [42, 43]])。<br/>
<code><br/>
11，查询结果的排序<br/>
</code><br/>
//查询花费超过10元的消费记录,并按升序排列<br/>
consumeItems = realm.objects(ConsumeItem.self).filter(&quot;cost &gt; 10&quot;).sorted(byProperty: &quot;cost&quot;)<br/>
<code><br/>
12，使用List实现一对多关系<br/>
List 中可以包含简单类型的 Object，表面上和可变的 Array 非常类似。<br/>
注意：List 只能够包含 Object 类型，不能包含诸如String之类的基础类型。 <br/>
如果打算给我们的 Person 数据模型添加一个“dogs”属性，以便能够和多个“dogs”建立关系，也就是表明一个 Person 可以有多个 Dog，那么我们可以声明一个List类型的属性：<br/>
</code><br/>
class Person: Object {<br/>
    ... // 其余的属性声明<br/>
    let dogs = List<Dog>()<br/>
}</p>

<p>// 这里我们就可以使用已存在的狗狗对象来完成初始化<br/>
let aPerson = Person(value: [&quot;李四&quot;, 30, [aDog, anotherDog]])</p>

<p>// 还可以使用多重嵌套<br/>
let aPerson = Person(value: [&quot;李四&quot;, 30, [[&quot;小黑&quot;, 5], [&quot;旺财&quot;, 6]]])<br/>
可以和之前一样，对 List 属性进行访问和赋值：</p>

<p>let someDogs = realm.objects(Dog.self).filter(&quot;name contains &#39;小白&#39;&quot;)<br/>
ZhangSan.dogs.append(objectsIn: someDogs)<br/>
ZhangSan.dogs.append(dahuang)<br/>
<code><br/>
反向关系(Inverse Relationship)<br/>
通过反向关系(也被称为反向链接(backlink))，您可以通过一个特定的属性获取和给定对象有关系的所有对象。 Realm 提供了“链接对象 (linking objects)” 属性来表示这些反向关系。借助链接对象属性，您可以通过指定的属性来获取所有链接到指定对象的对象。<br/>
例如，一个 Dog 对象可以拥有一个名为 owners 的链接对象属性，这个属性中包含了某些 Person 对象，而这些 Person 对象在其 dogs 属性中包含了这一个确定的 Dog 对象。您可以将 owners 属性设置为 LinkingObjects 类型，然后指定其关系，说明其当中包含了 Person 对象。<br/>
</code><br/>
class Dog: Object {<br/>
    dynamic var name = &quot;&quot;<br/>
    dynamic var age = 0</p>

<pre><code>// Realm 并不会存储这个属性，因为这个属性只定义了 getter
// 定义“owners”，和 Person.dogs 建立反向关系
let owners = LinkingObjects(fromType: Person.self, property: &quot;dogs&quot;)
</code></pre>

<p>}<br/>
<code><br/>
13，添加主键(Primary Keys) <br/>
重写 Object.primaryKey() 可以设置模型的主键。<br/>
声明主键之后，对象将被允许查询，更新速度更加高效，并且要求每个对象保持唯一性。<br/>
一旦带有主键的对象被添加到 Realm 之后，该对象的主键将不可修改。<br/>
</code><br/>
class Person: Object {<br/>
  dynamic var id = 0<br/>
  dynamic var name = &quot;&quot;</p>

<p>override static func primaryKey() -&gt; String? {<br/>
    return &quot;id&quot;<br/>
  }<br/>
}<br/>
<code><br/>
14，添加索引属性(Indexed Properties)<br/>
重写 Object.indexedProperties() 方法可以为数据模型中需要添加索引的属性建立索引：<br/>
</code><br/>
class Book: Object {<br/>
  dynamic var price = 0<br/>
  dynamic var title = &quot;&quot;</p>

<p>override static func indexedProperties() -&gt; [String] {<br/>
    return [&quot;title&quot;]<br/>
  }<br/>
}<br/>
<code><br/>
15，设置忽略属性(Ignored Properties)<br/>
重写 Object.ignoredProperties() 可以防止 Realm 存储数据模型的某个属性。Realm 将不会干涉这些属性的常规操作，它们将由成员变量(var)提供支持，并且您能够轻易重写它们的 setter 和 getter。<br/>
</code><br/>
class Person: Object {<br/>
  dynamic var tmpID = 0<br/>
  var name: String { // 计算属性将被自动忽略<br/>
    return &quot;(firstName) (lastName)&quot;<br/>
  }<br/>
  dynamic var firstName = &quot;&quot;<br/>
  dynamic var lastName = &quot;&quot;</p>

<p>override static func ignoredProperties() -&gt; [String] {<br/>
    return [&quot;tmpID&quot;]<br/>
  }<br/>
}<br/>
<code><br/>
16，修改更新数据 <br/>
（1）直接更新内容<br/>
</code><br/>
// 在一个事务中更新对象<br/>
try! realm.write {<br/>
  consumeItem.name = &quot;去北京旅行&quot;<br/>
}<br/>
<code><br/>
（2）通过主键更新<br/>
如果您的数据模型中设置了主键的话，那么您可以使用 Realm().add(_:update:) 来更新对象（当对象不存在时也会自动插入新的对象。）<br/>
</code><br/>
/****** 方式1 ***/<br/>
// 创建一个带有主键的“书籍”对象，作为事先存储的书籍<br/>
let cheeseBook = Book()<br/>
cheeseBook.title = &quot;奶酪食谱&quot;<br/>
cheeseBook.price = 9000<br/>
cheeseBook.id = 1</p>

<p>// 通过 id = 1 更新该书籍<br/>
try! realm.write {<br/>
    realm.add(cheeseBook, update: true)<br/>
}</p>

<p>/****** 方式2 ***/<br/>
// 假设带有主键值 <code>1</code> 的“书籍”对象已经存在<br/>
try! realm.write {<br/>
    realm.create(Book.self, value: [&quot;id&quot;: 1, &quot;price&quot;: 22], update: true)<br/>
    // 这本书的<code>title</code>属性不会被改变<br/>
}<br/>
（3）键值编码 <br/>
这个是在运行时才能决定哪个属性需要更新的时候，这个对于大量更新的对象极为有用。</p>

<p>let persons = realm.objects(Person.self)<br/>
try! realm.write {<br/>
    // 更新第一个<br/>
    persons.first?.setValue(true, forKeyPath: &quot;isFirst&quot;)<br/>
    // 将每个人的 planet 属性设置为“地球”<br/>
    persons.setValue(&quot;地球&quot;, forKeyPath: &quot;planet&quot;)<br/>
}<br/>
<code><br/>
17，删除数据<br/>
</code><br/>
let cheeseBook = ... // 存储在 Realm 中的 Book 对象</p>

<p>// 在事务中删除一个对象<br/>
try! realm.write {<br/>
  realm.delete(cheeseBook)<br/>
}<br/>
也能够删除数据库中的所有数据</p>

<p>// 从 Realm 中删除所有数据<br/>
try! realm.write {<br/>
  realm.deleteAll()<br/>
}<br/>
<code><br/>
18，Realm数据库配置 <br/>
（1）修改默认的的数据库<br/>
通过调用 Realm() 来初始化以及访问我们的 realm 变量。其指向的是应用的 Documents 文件夹下的一个名为“default.realm”的文件。<br/>
通过对默认配置进行更改，我们可以使用不同的数据库。比如给每个用户帐号创建一个特有的 Realm 文件，通过切换配置，就可以直接使用默认的 Realm 数据库来直接访问各自数据库：<br/>
</code><br/>
func setDefaultRealmForUser(username: String) {<br/>
    var config = Realm.Configuration()</p>

<pre><code>// 使用默认的目录，但是使用用户名来替换默认的文件名
config.fileURL = config.fileURL!.deletingLastPathComponent()
    .appendingPathComponent(&quot;\(username).realm&quot;)

// 将这个配置应用到默认的 Realm 数据库当中
Realm.Configuration.defaultConfiguration = config
</code></pre>

<p>}<br/>
<code><br/>
（2）打包进项目里的数据库的使用<br/>
如果需要将应用的某些数据（比如配置信息，初始化信息等）打包到一个 Realm 文件中，作为主要 Realm 数据库的扩展，操作如下：<br/>
</code><br/>
let config = Realm.Configuration(<br/>
    // 获取需要打包文件的 URL 路径<br/>
    fileURL: Bundle.main.url(forResource: &quot;MyBundledData&quot;, withExtension: &quot;realm&quot;),<br/>
    // 以只读模式打开文件，因为应用数据包并不可写<br/>
    readOnly: true)</p>

<p>// 通过配置打开 Realm 数据库<br/>
let realm = try! Realm(configuration: config)</p>

<p>// 通过配置打开 Realm 数据库<br/>
let results = realm.objects(Dog.self).filter(&quot;age &gt; 5&quot;)<br/>
<code><br/>
（3）内存数据库<br/>
内存数据库在每次程序运行期间都不会保存数据。但是，这不会妨碍到 Realm 的其他功能，包括查询、关系以及线程安全。 假如您需要灵活的数据读写但又不想储存数据的话，那么内存数据库对您来说一定是一个不错的选择。<br/>
</code><br/>
let realm = try! Realm(configuration: Realm.Configuration(inMemoryIdentifier: &quot;MyInMemoryRealm&quot;))<br/>
<code><br/>
19，加密数据库 <br/>
（1）加密后的 Realm文件不能跨平台使用（因为 NSFileProtection 只有 iOS 才可以使用） <br/>
（2）Realm 文件不能在没有密码保护的 iOS 设备中进行加密。为了避免这些问题（或者您想构建一个 OS X 的应用），可以使用 Realm 提供的加密方法。 <br/>
（3）加密过的 Realm 只会带来很少的额外资源占用（通常最多只会比平常慢10%）。<br/>
</code><br/>
/*****   在创建 Realm 数据库时采用64位的密钥对数据库文件进行 AES-256+SHA2 加密   ****/<br/>
// 产生随机密钥<br/>
var key = Data(count: 64)<br/>
_ = key.withUnsafeMutableBytes { bytes in<br/>
    SecRandomCopyBytes(kSecRandomDefault, 64, bytes)<br/>
}</p>

<p>// 打开加密文件<br/>
let config = Realm.Configuration(encryptionKey: key)<br/>
let realm:Realm<br/>
do {<br/>
    realm = try Realm(configuration: config)<br/>
} catch let error as NSError {<br/>
    // 如果密钥错误，<code>error</code> 会提示数据库不可访问<br/>
    fatalError(&quot;Error opening realm: (error)&quot;)<br/>
}</p>

<p>// 和往常一样使用 Realm 即可<br/>
let dogs = realm.objects(Book.self).filter(&quot;name contains &#39;Fido&#39;&quot;)<br/>
<code><br/>
20，数据迁移(Migration)<br/>
（1）为何要迁移<br/>
比如原来有如下 Person 模型：<br/>
</code><br/>
class Person: Object {<br/>
    dynamic var firstName = &quot;&quot;<br/>
    dynamic var lastName = &quot;&quot;<br/>
    dynamic var age = 0<br/>
}<br/>
<code><br/>
假如我们想要更新数据模型，给它添加一个 fullname 属性， 而不是将“姓”和“名”分离开来。<br/>
</code><br/>
class Person: Object {<br/>
    dynamic var fullName = &quot;&quot;<br/>
    dynamic var age = 0<br/>
}<br/>
```<br/>
在这个时候如果您在数据模型更新之前就已经保存了数据的话，那么 Realm 就会注意到代码和硬盘上数据不匹配。 每当这时，您必须进行数据迁移，否则当您试图打开这个文件的话 Realm 就会抛出错误。 </p>

<p>（2）如何进行数据迁移<br/>
假设我们想要把上面所声明 Person 数据模型进行迁移。如下所示是最简单的数据迁移的必需流程：</p>

<p>// 在(application:didFinishLaunchingWithOptions:)中进行配置<br/>
 ```<br/>
let config = Realm.Configuration(<br/>
  // 设置新的架构版本。这个版本号必须高于之前所用的版本号<br/>
  // （如果您之前从未设置过架构版本，那么这个版本号设置为 0）<br/>
  schemaVersion: 1,</p>

<p>// 设置闭包，这个闭包将会在打开低于上面所设置版本号的 Realm 数据库的时候被自动调用<br/>
  migrationBlock: { migration, oldSchemaVersion in<br/>
    // 目前我们还未进行数据迁移，因此 oldSchemaVersion == 0<br/>
    if (oldSchemaVersion &lt; 1) {<br/>
      // 什么都不要做！Realm 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构<br/>
    }<br/>
  })</p>

<p>// 告诉 Realm 为默认的 Realm 数据库使用这个新的配置对象<br/>
Realm.Configuration.defaultConfiguration = config<br/>
 ```<br/>
// 现在我们已经告诉了 Realm 如何处理架构的变化，打开文件之后将会自动执行迁移<br/>
let realm = try! Realm()<br/>
虽然这个迁移操作是最精简的了，但是我们需要让这个闭包能够自行计算新的属性（这里指的是 fullName），这样才有意义。 在迁移闭包中，我们能够调用Migration().enumerateObjects(_:_:) 来枚举特定类型的每个 Object 对象，然后执行必要的迁移逻辑。注意，对枚举中每个已存在的 Object 实例来说，应该是通过访问 oldObject 对象进行访问，而更新之后的实例应该通过 newObject 进行访问：</p>

<p>// 在 application(application:didFinishLaunchingWithOptions:) 中进行配置<br/>
 <code><br/>
Realm.Configuration.defaultConfiguration = Realm.Configuration(<br/>
  schemaVersion: 1,<br/>
  migrationBlock: { migration, oldSchemaVersion in<br/>
    if (oldSchemaVersion &lt; 1) {<br/>
      // enumerateObjects(ofType:_:) 方法遍历了存储在 Realm 文件中的每一个“Person”对象<br/>
      migration.enumerateObjects(ofType: Person.className()) { oldObject, newObject in<br/>
        // 将名字进行合并，存放在 fullName 域中<br/>
        let firstName = oldObject![&quot;firstName&quot;] as! String<br/>
        let lastName = oldObject![&quot;lastName&quot;] as! String<br/>
        newObject![&quot;fullName&quot;] = &quot;\(firstName) \(lastName)&quot;<br/>
      }<br/>
    }<br/>
  })<br/>
</code><br/>
21，使用带有 REST API 功能的 Realm 数据库示例<br/>
我们将从 豆瓣FM的API 那里获取一组 JSON 格式的频道数据，然后将它以 Realm Objects 的形式储存到默认的 Realm 数据库里。 <br/>
（1）json数据格式如下：<br/>
<code><br/>
{ <br/>
 &quot;channels&quot;: [<br/>
        {<br/>
            &quot;name_en&quot;: &quot;Personal Radio&quot;,<br/>
            &quot;seq_id&quot;: 0,<br/>
            &quot;abbr_en&quot;: &quot;My&quot;,<br/>
            &quot;name&quot;: &quot;私人兆赫&quot;,<br/>
            &quot;channel_id&quot;: 0<br/>
        },<br/>
        {<br/>
            &quot;name&quot;: &quot;华语&quot;,<br/>
            &quot;seq_id&quot;: 0,<br/>
            &quot;abbr_en&quot;: &quot;&quot;,<br/>
            &quot;channel_id&quot;: &quot;1&quot;,<br/>
            &quot;name_en&quot;: &quot;&quot;<br/>
        },<br/>
        {<br/>
            &quot;name&quot;: &quot;欧美&quot;,<br/>
            &quot;seq_id&quot;: 1,<br/>
            &quot;abbr_en&quot;: &quot;&quot;,<br/>
            &quot;channel_id&quot;: &quot;2&quot;,<br/>
            &quot;name_en&quot;: &quot;&quot;<br/>
        }<br/>
    ]<br/>
}<br/>
</code><br/>
（2）我们将直接把 Dictionary 插入到 Realm 中，然后让 Realm 自行快速地将其映射到 Object 上。<br/>
（从 iOS9 起，新特性要求App访问网络请求，要采用 HTTPS 协议。直接请求HTTP数据会报错，解决办法可以参照的我另一篇文章：Swift - 网络请求报App Transport Security has blocked a cleartext错）<br/>
为了确保示例能够成功，我们需要一个所有属性完全匹配 JSON 键结构的 Object 结构体。如果 JSON 的键结构不匹配 Object 结构体属性结构的话，那么就会在插入时被忽略。<br/>
```<br/>
import UIKit<br/>
import RealmSwift</p>

<p>class ViewController: UIViewController {</p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()

    // 调用API
    let url = URL(string: &quot;http://www.douban.com/j/app/radio/channels&quot;)!
    let response = try! Data(contentsOf: url)

    // 对 JSON 的回应数据进行反序列化操作
    let json = try! JSONSerialization.jsonObject(with: response,
                            options: .allowFragments) as! [String:Any]
    let channels = json[&quot;channels&quot;] as! [[String:Any]]

    let realm = try! Realm()
    try! realm.write {
        // 为数组中的每个元素保存一个对象（以及其依赖对象）
        for channel in channels {
            if channel[&quot;seq_id&quot;] as! Int == 0 {continue} //第一个频道数据有问题,丢弃三
            realm.create(DoubanChannel.self, value: channel, update: true)
        }
    }

    print(realm.configuration.fileURL)
}

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}
</code></pre>

<p>}<br/>
 ```</p>

<pre><code>//豆瓣频道
class DoubanChannel:Object {
    //频道id
    dynamic var channel_id = &quot;&quot;
    //频道名称
    dynamic var name = &quot;&quot;
    //频道英文名称
    dynamic var name_en = &quot;&quot;
    //排序
    dynamic var seq_id = 0
    dynamic var abbr_en = &quot;&quot;
     
    //设置主键
    override static func primaryKey() -&gt; String? {
        return &quot;channel_id&quot;
    }
}
```

（3）可以看到数据已经成功插入到库中了
原文:Swift - Realm数据库的使用详解（附样例）


22，当前版本的限制
Realm 致力于平衡数据库读取的灵活性和性能。为了实现这个目标，在 Realm 中所存储的信息的各个方面都有基本的限制。例如：
（1）类名称的长度最大只能存储 57 个 UTF8 字符。
（2）属性名称的长度最大只能支持 63 个 UTF8 字符。
（3）NSData 以及 String 属性不能保存超过 16 MB 大小的数据。如果要存储大量的数据，可通过将其分解为16MB 大小的块，或者直接存储在文件系统中，然后将文件路径存储在 Realm 中。如果您的应用试图存储一个大于 16MB 的单一属性，系统将在运行时抛出异常。
（4）对字符串进行排序以及不区分大小写查询只支持“基础拉丁字符集”、“拉丁字符补充集”、“拉丁文扩展字符集 A” 以及”拉丁文扩展字符集 B“（UTF-8 的范围在 0~591 之间）。


</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14938901246167.html">
                
                  <h1>protocol buffer在iOS中的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>安装环境：</p>

<pre><code>1. brew install automake
2. brew install libtool
3. brew install protobuf
</code></pre>

<p>安装好以后使用<code>protoc --help</code>看下是否有这个玩意<code>--objc_out</code>如果有就可以用protoc编译生成objective-c的代码了<br/>
如果没有</p>

<pre><code>1. gitclonegit@github.com:alexeyxo/protobuf-objc.git

2. cdprotobuf-objc

3. ./autogen.sh

# 后面的参数保证 configure 能找到 protobuf 相关的头文件和库

# 避免报 protobuf headers are required 错误

4. ./configure CXXFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib

5. make

6. make install
</code></pre>

<p>编写proto文件：<br/>
文件名为<code>user.proto</code></p>

<pre><code class="language-syntax">
message Contact {
  string first_name = 1;
  string last_name = 2;
};

message TestMessage{
    string name = 1;
    string address = 2;
    Contact con = 3;
};
</code></pre>

<p>使用protoc生成所需文件：<br/>
1.生成oc的代码</p>

<pre><code>protoc user.proto(这里是proto文件路径） --objc_out=“生成oc的路径”
</code></pre>

<p>2.生成swfit代码<br/>
按照<code>https://github.com/apple/swift-protobuf</code>上面的说明，安装swift的plugin<br/>
然后运行如下命令</p>

<pre><code>protoc --plugin=protoc-gen-swift=“protoc-gen-swift所在路径” --swift_out=“生成的swfit路径” “proto文件所在路径”
例如
protoc --plugin=protoc-gen-swift=/Users/xxx/swift-protobuf/.build/debug/protoc-gen-swift --swift_out=. user.proto
</code></pre>

<p>使用</p>

<pre><code>func getTestMessage(name:String,address:String) -&gt; TestMessage {
        var t = TestMessage()
        t.name = name
        t.address = address
        return t
    }
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14938045272036.html">
                
                  <h1>Github 搜索技巧</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>具体请移步：<a href="http://www.jianshu.com/p/7321caea2a08">http://www.jianshu.com/p/7321caea2a08</a></p>

<ol>
<li>Search
如何查看一门语言的 Repository 排行榜（按 stars 数量排）？
如图所示，以 Objective-C 为例，直接在输入框中输入 language:Objective-C stars:&gt;0， 然后再在右侧排名选项中选择 Most stars。
为什么有些数据模糊搜索不到？
比如，输入搜索关键字 “collectionView”，然后在左侧边栏 Languages 中选择 Objective-C ，发现搜索结果中没有 “PSTCollectionView” 这个Repository，实际上，如果搜索的是 “PSTCollectionView” 的话，确实是能搜索到的。
从搜索结果中来看，“collectionView” 是被作为一个单词整体来进行搜索的，所以搜到的结果都是 Repository name 或者 description 中出现以 “collectionView” 开头或者包含 “-collectionView” 的单词的 Repository。
所以为了能搜索到更多想要的结果，我们最好以单词为单位，用 OR 将各个关键字拼接起来进行搜索，例如，搜 “CollectionView OR UICollectionView OR collection” 而不是 “collectionView”。
下面是两种搜索词的结果对比。</li>
</ol>

<p>2.Trending</p>

<p>作为一枚程序猿，除了有目的的搜索之外，我们有时也需要去“瞎逛逛”，开阔一下眼界。如果你有空，不妨去 Github 的 <a href="https://github.com/trending">Trending</a> 看看最近发生了什么。See what the GitHub community is most excited about today! 在这里你可以看到各种不同开发语言的每天/周/月的最热门的 Repositories 和 Developers。比如前一段时间走红的 YYKit，苹果最近开源的 CareKit，等等。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14919781270379.html">
                
                  <h1>Git合并特定commits 到另一个分支</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>有时候会遇到这种情况，对一个项目开了不同的几个分支，在开发的时候应该是要在A上开发的，结果跑到了B上面去，提交合并的时候也没看到，结果就郁闷了，各种混乱，回滚，代码没了。修改后再合并，会影响到对应的分支，最好就是针对某几次的提交，合并的特定的分支上。这个是可以实现的。<br/>
做了如下的实验<br/>
<img src="media/14919781270379/14919782919144.jpg" alt=""/><br/>
master上输入1，2，3，4，5<br/>
dev上1，2，3，4，5，6，7，8<br/>
master上要实现1，2，3，4，5，7这样的功能，也就是要把dev上的7这次提交合并到master上。我是这么做的<br/>
首先通过master再拉一个分支dev2（也可以不用拉），然后找到7的这次提交“f572e2a”，运行如下命令：<code>git cherry-pick f572e2a</code>，如果有冲突，解决冲突后即可。</p>

<p><strong>合并某个分支上的一系列commits</strong><br/>
在一些特性情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要选择cherry-pick了，rebase 更适合。还以上例为例，假设你需要合并feature分支的commit aa7aa5d ~5bfe5c0 到master分支。<br/>
首先需要基于feature创建一个新的分支，并指明新分支的最后一个commit：<code>git checkout -bnewbranch 5bfe5c0</code><br/>
然后，rebase这个新分支的commit到master（--ontomaster）。aa7aa5d^ 指明你想从哪个特定的commit开始。<code>git rebase --ontomaster aa7aa5d^</code><br/>
得到的结果就是feature分支的commit aa7aa5d ~5bfe5c0 都被合并到了master分支。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>寒夜孤灯</h1>
                <div class="site-des">寒夜里的一盏孤灯</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>分类</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="iOS.html"><strong>iOS</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="PHP.html"><strong>PHP</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E6%9D%82%E8%B0%88.html"><strong>杂谈</strong></a>
        
            <a href="%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87.html"><strong>疑难杂症</strong></a>
        
            <a href="Redis.html"><strong>Redis</strong></a>
        
            <a href="React%20Native.html"><strong>React Native</strong></a>
        
            <a href="%E8%BF%90%E7%BB%B4.html"><strong>运维</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>最新文章</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15036253170711.html">Xcode Build Settings 分析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15030458956017.html">发现女儿早恋，这个爸爸的做法刷爆朋友圈！</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15017301944011.html">iOS应用内跳转到系统设置页面</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15017289646320.html">iOS APP提交审核被拒因Guideline 2.5.2 - Performance - Software Requirements</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14966306832048.html">Swift使用pod找不到文件的解决方案</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2017
通过 <a target="_blank" href="http://www.mweb.im">MWeb</a>制作&nbsp; <a target="_blank" href="http://www.miitbeian.gov.cn/">沪ICP备15015428号-1</a>&nbsp; 
</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
